Calling conventions, stack frame and zero page:

The variables that normally are placed on the stack or in registers in C
are instead allocated in the zero page and saved on a (fictive) stack
when calling functions.  Some locations have predefined functions though.

The stack will first increment, then store values.
Frame pointer is kept in AC3 and ZP "fp" (or HW FP).
Stack pointer is kept in ZP "sp".
Stack reference pointer is kept in ZP "spref".
Stack reference pointer is the top of stack and used to restore stack
after a function call.  This offset on the stack is unallocated and used
when calling subroutines.

#ifdef 2bsd
0-7	Unused (by us)
11	Frame pointer	(if lacking HW stack)
12	Stack pointer
20-26	(Auto-increment), scratch
30-37	(Auto-decrement), scratch
40-47	Used by HW stack and MMPU
100-377	Addresses for subroutines, written by the linker
#elif rdos
0-17	Unused (by us)
20-27	(Auto-increment), scratch
30-37	(Auto-decrement), scratch
40-47	Used by HW stack and MMPU
50-377	Addresses for subroutines, written by the linker
#endif

The normal registers (AC0-AC2) are all considered scratch registers.

Register classes are assigned as:
	AC0-AC2: AREGs.
	AC2: BREGs.
	...and eventually register pairs/floats as EREGs, double in FREGs.

In byte code the right half of a word is the first byte (little-endian).
This is different to how the hardware handle it.

Stack frame layout (with frame pointer). 2+1 words to save on stack:
Stack grows upward

 sp ->	! free	! 3	<- also spref
	! w2	! 2
	! w1	! 1
 fp ->	! ospref! 0
 	! ofp	! -1
	! arg0	! -2	<- stack pointer when enter new function
	! arg1	! -3
ospref->! opc	! -4

Return values are in ac0 (and ac1).

The prolog/epilog (csav/cret); they are implemented as subroutines.
Both can be omitted if the function do not need it, but the FP in AC3
must be restored.

sp is either in loc 027 (auto-inc) or in HW stack.

calling function 2-arg: (cleanup done in return function)
	sta arg2,@sp	/	push arg2
	sta arg1,@sp	/	push arg1
	jsr @_fun	/	jsr @_fun


in function: (2 words used on stack)
	sta 3,@spref	/	sta 3,@spref
	jsr @_csav	/	jsr @_csav
	.word 2		/	.word 2
	...
	jmp @_cret	/	jmp @_cret

csav: 
	lda 1,0,3	/	lda 1,0,3	# fetch words on stack
	inc 3,2		/	inc 3,2		# put return address in ac2

	lda 0,fp	/	mffp 0		# fetch fp
	sta 0,@sp	/	push 0		# ...and push
	lda 0,spref	/	lda 0,spref	# fetch spref
	sta 0,@sp	/	push 0		# ...and push
	lda 3,sp	/	mfsp 3		# fetch sp
	sta 3,fp	/	mtfp 3		# save sp as new fp

	add 3,1		/	add 3,1		# calc new stack pointer
	sta 1,sp	/	mtsp 1		# store
	sta 1,spref	/	sta 1,spref	# store spref as well 
	jmp 0,2		/	jmp 0,2		# return

cret:
	lda 2,0,3	/	lda 2,0,3	# old sp/spref
	sta 2,spref	/	sta 2,spref
	lda 3,-1,3	/	lda 3,-1,3	# old fp
	sta 3,fp	/	mtfp 3		# restore fp
	sta 2,sp	/	mtsp 2		# cleanup stack
	jmp @0,2	/	jmp @0,2


# little-endian bytes. 
# load byte, ptr in ac2, ret in ac0
lbyte:	sta 3,@spref	# save return address
	
	lda 1,[377]	# get byte mask
	movr 2,2,szc	# skip next if right word
	movs 1,1	# swap mask
	lda 0,,2	# load word into ac0
	and 1,0,szc	# mask our wanted word
	movs 0,0	# swap back if left

	lda 3,fp	# restore ac3
	jmp 0,@spref	# get back

# save byte, ptr in ac2, byte in right half of ac0
sbyte:	sta 3,@spref

	lda 3,[377]	# mask
	and 3,0		# Ensure ac0 high byte is clear

	movr 2,2,szc	# skip next if left half
	movs 0,0,skp	# right half; swap input byte
	movs 3,3	# left half; swap mask

	lda 1,,2	# get word
	and 3,1		# mask out saved half
	add 0,1		# merge in other half
	sta 1,2		# write back

	lda 3,fp
	jmp @spref

# shift ac0 left ac1 times
shl:	sta 3,@spref
	neg 1,1,snr	# negate count.
	jmp out		# done if no shift

	movzl 0,0	# shift left
	inc 1,1,szr	# done?
	jmp .-2
out:
	lda 3,fp
	jmp @spref
